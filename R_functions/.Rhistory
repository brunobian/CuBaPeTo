rPath = '/home/brunobian/Documentos/Repos/CuBaPeTo/R_functions'
source(paste0(rPath, '/iter.across_subject.R'))
iteraciones
n_iter+1
c(n_iter+1)
dim(ite)[2]
model
efects
lmer
library(lme4)
effects
effectsLmm
rPath = "~/Documentos/Repos/CuBaPeTo//R_functions/"
paste0(rPath, '/generateIterMatrix.R')
source(paste0(rPath, '/generateIterMatrix.R'))
source(paste0(rPath, '/lmmElecTime.R'))
source(paste0(rPath, '/LmElecTime.R'))
tStart     = 1
tEnd       = 10
nIter      = 50
inPath     = "~/Documentos/Repos/CuBaPeTo/example/csv/"
tStart
tEnd
nIter
inPath
outPath
outPath = "~/Documentos/Repos/CuBaPeTo/example/LMM/result/"
modType = 'lmm'
rPath
fixEf
fixEf = '(freq + pos + pred) * type'
ranEf = '(1|suj) + (1|word)'
perPath = '~/Documentos/Repos/CuBaPeTo/example/LMM/permutations/'
perVar=''
cstPath
cstPath = '~/Documentos/Repos/CuBaPeTo/example/'
total.start <- Sys.time()
options(warn=-1)
require(lme4)
source(paste0(rPath, '/generateIterMatrix.R'))
source(paste0(rPath, '/lmmElecTime.R'))
source(paste0(rPath, '/lmElecTime.R'))
source(paste0(rPath, '/lmmTimeWindow.R'))
source(paste0(cstPath, '/process.data.R'))
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
file_name = paste(in_path, 't1.csv', sep = '')
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
require(lme4)
source(paste0(rPath, '/generateIterMatrix.R'))
source(paste0(rPath, '/lmmElecTime.R'))
source(paste0(rPath, '/lmElecTime.R'))
source(paste0(rPath, '/lmmTimeWindow.R'))
source(paste0(cstPath, '/process.data.R'))
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
!file.exists(perPath)
perPath
fn = paste0(perPath, perms, '_', perVar, nIter)
fn = paste0(perPath, 'perms_', perVar, nIter)
(!file.exists(fn))
print('Generating a new permutation matrix')
# Generate new permutation matrix or load an existing one
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
perPath
!file.exists(fn)
# Generate new permutation matrix or load an existing one
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
file_name = paste(inPath, 't1.csv', sep = '')
file_name
tmp <- read.csv(file_name, comment.char = "", sep=";")
tmp <- read.csv(file_nazme, comment.char = "", sep=";")
tmp <- read.csv(file_name, comment.char = "", sep=";")
file_name = paste(inPath, 't1000.csv', sep = '')
tmp <- read.csv(file_name, comment.char = "", sep=";")
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
source(paste0(rPath, '/generateIterMatrix.R'))
source(paste0(rPath, '/lmmElecTime.R'))
source(paste0(rPath, '/lmElecTime.R'))
source(paste0(rPath, '/lmmTimeWindow.R'))
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
cstPath
source(paste0(cstPath, '/processData.R'))
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
file_name = paste(inPath, 't1000.csv', sep = '')
tmp <- read.csv(file_name, comment.char = "", sep=";")
source(paste0(rPath, '/generateIterMatrix.R'))
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
source(paste0(rPath, '/generateIterMatrix.R'))
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
outPath    = args[5]
modType    = args[6]
outPath
modType
rPath
source(paste0(rPath, '/generateIterMatrix.R'))
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
file_name = paste(inPath, 't1000.csv', sep = '')
tmp <- read.csv(file_name, comment.char = "", sep=";")
L = length(tmp$E1)
source(paste0(rPath, '/generateIterMatrix.R'))
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
source(paste0(rPath, '/generateIterMatrix.R'))
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
tmp
dataSet = tmp
dataSet <- dataSet[dataSet$palnum <= 10,] # Elimino las pals que estÃ¡n dsp de la 10ma
dataSet <- dataSet[dataSet$bad_epoch == 0,] # Elimino los malos trials
dataSet$tipo[dataSet$tipo >  0] = 1
dataSet$tipo <- as.factor(dataSet$tipo)
dataSet$freq   <- log(dataSet$freq+1)
dataSet$length <- 1/(dataSet$length)
dataSet$freq   <- scale(dataSet$freq,   center = TRUE, scale = FALSE)
dataSet$pred   <- scale(dataSet$pred,   center = TRUE, scale = FALSE)
dataSet$palnum <- scale(dataSet$palnum, center = TRUE, scale = FALSE)
dataSet$length <- scale(dataSet$length, center = TRUE, scale = FALSE)
dataSet$palnum <- scale(dataSet$palnum, center = TRUE, scale = FALSE)
dataSet$freq   <- log(dataSet$freq+1)
dataSet$length <- 1/(dataSet$length)
dataSet$freq   <- scale(dataSet$freq,   center = TRUE, scale = FALSE)
dataSet$freq   <- log(dataSet$freq+1)
dataSet$length <- 1/(dataSet$length)
1/(dataSet$length)
dataSet$length
dataSet
dataSet$lngth
dataSet$length <- 1/(dataSet$lngth)
dataSet$freq   <- scale(dataSet$freq,   center = TRUE, scale = FALSE)
dataSet$pred   <- scale(dataSet$pred,   center = TRUE, scale = FALSE)
dataSet$palnum <- scale(dataSet$palnum, center = TRUE, scale = FALSE)
dataSet$length <- scale(dataSet$length, center = TRUE, scale = FALSE)
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
ix.R'))
source(paste0(rPath, '/lmmElecTime.R'))
source(paste0(rPath, '/lmElecTime.R'))
source(paste0(rPath, '/lmmTimeWindow.R'))
source(paste0(cstPath, '/processData.R'))
# Generate new permutation matrix or load an existing one
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
source(paste0(rPath, '/generateIterMatrix.R'))
source(paste0(rPath, '/lmmElecTime.R'))
source(paste0(rPath, '/lmElecTime.R'))
source(paste0(rPath, '/lmmTimeWindow.R'))
source(paste0(cstPath, '/processData.R'))
# Generate new permutation matrix or load an existing one
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
source(paste0(rPath, '/generateIterMatrix.R'))
source(paste0(rPath, '/lmmElecTime.R'))
source(paste0(rPath, '/lmElecTime.R'))
source(paste0(rPath, '/lmmTimeWindow.R'))
source(paste0(cstPath, '/processData.R'))
# Generate new permutation matrix or load an existing one
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
# Check for previuos iterations matrices
# This is important when runing on prarallel, because it is necesarry to keep the permutations
fn = paste0(perPath, 'perms_', perVar, nIter)
if (!file.exists(fn)) {
print('Generating a new permutation matrix')
# Load t1.csv as example for calculating amount of rows
file_name = paste(inPath, 't1000.csv', sep = '')
tmp <- read.csv(file_name, comment.char = "", sep=";")
L = length(tmp$E1)
# Custom function for data preprocessing
# It is important to apply same process here than in th final analysis,
# in order to have the same dataset
tmp <- processData(tmp)
print("procesado")
# Create exmpty matrix with L rows
iterations = matrix(NA, L, 0)
# Create a secuential vector [1:L] and add to interactions in the first column
# Thus, first run will be without iterations
s = c(1:L)
iterations <- cbind(iterations, s)
# Generate permutations columns within perVar
# if perVar == 0 -> permutate across all random Variables
for (iter in 1:nIter){
if (perVar == '') {
thisIter = sample(s)
iterations <- cbind(iterations, thisIter)
} else {
perVarUn = unique(tmp[perVar])
for (iPerVar in perVarUn){
indIhisIter = s[tmp[perVar] == iPerVar]
thisIter[indIhisIter] = sample(indIhisIter)
}
iterations <- cbind(iterations, thisIter)
}
}
}
perPath
iterations
perPath
write.table(iterations, perPath, sep = ",", row.names = FALSE, col.names = FALSE)
perPath
source(paste0(rPath, '/generateIterMatrix.R'))
source(paste0(rPath, '/lmmElecTime.R'))
source(paste0(rPath, '/lmElecTime.R'))
source(paste0(rPath, '/lmmTimeWindow.R'))
source(paste0(cstPath, '/processData.R'))
# Generate new permutation matrix or load an existing one
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
inPath
iTime
iTime=1
fileName = paste(inPath, 't', iTime, '.csv', sep = '')
print(paste0('Loading file T', iTime))
tmp <- read.csv(fileName, comment.char = "", sep=";")
tmp <- processData(tmp)
out <- list()
indE=1
electrode = paste0('E', indE)
nIter = dim(iterations)[2]
iter=1
[iterations[,iter], ]
tmp[electrode][iterations[,iter], ]
tmp[electrode] <- tmp[electrode][iterations[,iter], ]
length(tmp)
length(tmp$suj_id)
length(iterations)
length(iterations[1,])
length(iterations[,1])
fileName = paste(inPath, 't', iTime=2, '.csv', sep = '')
fileName
tmp <- read.csv(fileName, comment.char = "", sep=";")
tmp <- processData(tmp)
tmp[electrode] <- tmp[electrode][iterations[,iter], ]
length(tmp$suj_id)
dim(iterations)[2]
slopes
fileName
tmp <- read.csv(fileName, comment.char = "", sep=";")
tmp <- processData(tmp)
out <- list()
for (indE in 1:128) {
electrode = paste0('E', indE)
nIter = dim(iterations)[2]
for (iter in 1:nIter){
tmp[electrode] <- tmp[electrode][iterations[,iter], ]
if (perType == 'lm'){
out = lmElecTime(tmp, indE, variables, iter, nIter, out)
} else {
out = lmmElecTime(tmp, indE, variables, iter, nIter, out)
}
}
}
iterations
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
iterations
out <- list()
for (indE in 1:128) {
electrode = paste0('E', indE)
nIter = dim(iterations)[2]
for (iter in 1:nIter){
tmp[electrode] <- tmp[electrode][iterations[,iter], ]
if (perType == 'lm'){
out = lmElecTime(tmp, indE, variables, iter, nIter, out)
} else {
out = lmmElecTime(tmp, indE, variables, iter, nIter, out)
}
}
}
source(paste0(rPath, '/generateIterMatrix.R'))
iterations <- generateIterMatrix(nIter, perVar, inPath, perPath)
iterations
out <- list()
for (indE in 1:128) {
electrode = paste0('E', indE)
nIter = dim(iterations)[2]
for (iter in 1:nIter){
tmp[electrode] <- tmp[electrode][iterations[,iter], ]
if (perType == 'lm'){
out = lmElecTime(tmp, indE, variables, iter, nIter, out)
} else {
out = lmmElecTime(tmp, indE, variables, iter, nIter, out)
}
}
}
perType
perType = 'lmm'
fileName = paste(inPath, 't', iTime, '.csv', sep = '')
print(paste0('Loading file T', iTime))
tmp <- read.csv(fileName, comment.char = "", sep=";")
# Custom function for data preprocessing
tmp <- processData(tmp)
out <- list()
for (indE in 1:128) {
electrode = paste0('E', indE)
nIter = dim(iterations)[2]
for (iter in 1:nIter){
tmp[electrode] <- tmp[electrode][iterations[,iter], ]
if (perType == 'lm'){
out = lmElecTime(tmp, indE, variables, iter, nIter, out)
} else {
out = lmmElecTime(tmp, indE, variables, iter, nIter, out)
}
}
}
variables = '(freq + palnum + pred) * tipo'
variables = '(freq + palnum + pred) * tipo + (1|suj_id) + (1|pal)'
fileName = paste(inPath, 't', iTime, '.csv', sep = '')
print(paste0('Loading file T', iTime))
tmp <- read.csv(fileName, comment.char = "", sep=";")
# Custom function for data preprocessing
tmp <- processData(tmp)
out <- list()
for (indE in 1:128) {
electrode = paste0('E', indE)
nIter = dim(iterations)[2]
for (iter in 1:nIter){
tmp[electrode] <- tmp[electrode][iterations[,iter], ]
if (perType == 'lm'){
out = lmElecTime(tmp, indE, variables, iter, nIter, out)
} else {
out = lmmElecTime(tmp, indE, variables, iter, nIter, out)
}
}
}
effectsLMM = out$effects
slopes     = out$slopes
t_values   = out$t_values
AIC_mat    = out$AIC_mat
lEf        = length(effectsLMM)
iEf=1
variable = names(effectsLMM[iEf])
variable
lEf
f = paste0(outPath, 'p_', variable, '_T', iTime)
f
write.table(slopes[,,iEf], f, sep = ",", row.names = FALSE, col.names = FALSE)
outPath
outPath = "~/Documentos/Repos/CuBaPeTo/example/LMM/results/"
f = paste0(outPath, 'p_', variable, '_T', iTime)
write.table(slopes[,,iEf], f, sep = ",", row.names = FALSE, col.names = FALSE)
